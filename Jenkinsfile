pipeline {
    agent any

    environment {
        DOCKER_IMAGE = 'juanjothin/vitalapp'
        DOCKER_TAG = 'latest'
        REGISTRY_CREDENTIALS = 'Token-docker'
    }

    parameters {
        // Por defecto usar la rama 'Tests' (la rama donde tienes configurado el pipeline)
        string(name: 'GIT_BRANCH', defaultValue: 'Tests', description: 'Rama a compilar desde GitHub')
    }

    options {
        timestamps()
        // ansiColor requiere el plugin "AnsiColor" instalado/activo en Jenkins.
        // Si al ejecutar aparece "Invalid option type 'ansiColor'", es porque el plugin no está instalado
        // o está desactualizado. Puedes reinstalarlo/actualizarlo y volver a habilitar la línea siguiente.
        // ansiColor('xterm')
    }

    stages {
        stage('Checkout') {
            steps {
                deleteDir()
                checkout([$class: 'GitSCM',
                          branches: [[name: "*/${params.GIT_BRANCH}"]],
                          doGenerateSubmoduleConfigurations: false,
                          extensions: [],
                          userRemoteConfigs: [[url: 'https://github.com/londgav01S/VitalCare-Back.git']]])
            }
        }

        stage('Compilar (Gradle)') {
            steps {
                sh 'chmod +x ./gradlew'
                sh "rm -rf ${env.HOME}/.gradle"
                sh './gradlew clean'
                // Construye el artefacto sin ejecutar tests
                sh './gradlew bootJar -x test'
            }
        }

        stage('Análisis SonarQube') {
            steps {
                withSonarQubeEnv('sonarqube-local') {
                    script {
                        echo "=== DEBUG: Variables de entorno Sonar ==="
                        sh 'echo "SONAR_HOST_URL = $SONAR_HOST_URL"'
                        sh 'echo "SONAR_AUTH_TOKEN = ${SONAR_AUTH_TOKEN:+***}"'
                        sh 'echo "Ejecutando análisis con Gradle..."'
                        sh './gradlew sonarqube -Dsonar.host.url=$SONAR_HOST_URL -Dsonar.login=$SONAR_AUTH_TOKEN'
                    }
                }
            }
        }

        stage('Tests (JUnit + Postman)') {
            steps {
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                    // Generar properties de test en el agente (H2 in-memory) para CI
                    // Esto evita subir archivos con secretos al repositorio.
                    sh '''
                        mkdir -p src/test/resources || true
                        cat > src/test/resources/application.properties <<'EOF'
                        # Test properties - generated by CI
                        spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL
                        spring.datasource.driver-class-name=org.h2.Driver
                        spring.datasource.username=sa
                        spring.datasource.password=
                        spring.jpa.hibernate.ddl-auto=create-drop
                        spring.jpa.show-sql=false
                        spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
                        sendgrid.api.key=
                        sendgrid.from.email=test@example.com
                        jwt.secret=test_jwt_secret
                        jwt.expirationMs=3600000
                        jwt.refreshExpirationMs=604800000
                        logging.level.org.springframework=ERROR
                        EOF
                    '''
                    // Ejecuta los tests JUnit que ya existen en el proyecto
                    sh './gradlew test'
                    // Publica resultados JUnit
                    junit 'build/test-results/test/*.xml'

                    script {
                        // Tests de API (Postman/Newman) opcionales si existe la colección
                        if (fileExists('tests/postman_collection.json')) {
                            sh '''
                                echo "Levantando servidor Spring Boot para tests de API..."
                                nohup java -jar build/libs/*.jar --spring.profiles.active=test > app.log 2>&1 &
                                SERVER_PID=$!
                                sleep 15 || true
                                echo "Ejecutando tests Newman..."
                                newman run tests/postman_collection.json --insecure || true
                                echo "Deteniendo servidor..."
                                kill $SERVER_PID || true
                            '''
                        } else {
                            echo 'No se encontró tests/postman_collection.json; se omiten tests de Postman.'
                        }
                    }
        stage('Optional: Docker build & push') {
            when {
                    anyOf {
                    expression { return env.DOCKER_IMAGE != null } // run only if DOCKER_IMAGE is set (flexible)
            }
                        }
            steps {
                script {
                    // Check if docker CLI is available on agent
                    def dockerAvailable = false
                    if (isUnix()) {
                        dockerAvailable = (sh(script: 'command -v docker >/dev/null 2>&1 && echo OK || echo NO', returnStdout: true).trim() == 'OK')
                    } else {
                        dockerAvailable = (bat(script: 'where docker >nul 2>nul && echo OK || echo NO', returnStdout: true).trim() == 'OK')
                    }

                    if (!dockerAvailable) {
                        echo "Docker no disponible en este agente — se salta Docker build (esto NO falla el pipeline)."
                    } else {
                        echo "Docker disponible — build de imagen: ${env.DOCKER_IMAGE}:${env.DOCKER_TAG}"
                        if (isUnix()) {
                        sh "docker build -t ${env.DOCKER_IMAGE}:${env.DOCKER_TAG} ."
                        // Push solo si DOCKER_IMAGE contiene registry and you have credentials set up in agent
                        // sh "docker push ${env.DOCKER_IMAGE}:${env.DOCKER_TAG}"
                        } else {
                        bat "docker build -t ${env.DOCKER_IMAGE}:${env.DOCKER_TAG} ."
                        }
                    }
                }
            }
        }

        
    }
    post {
    always {
      archiveArtifacts artifacts: '**/build/reports/tests/test/**', allowEmptyArchive: true
      // You can publish more artifacts or notifications here
    }
    success {
      echo "Pipeline terminado con éxito."
    }
    failure {
      echo "Pipeline falló — revisa console output y reportes."
    }
  }
}
