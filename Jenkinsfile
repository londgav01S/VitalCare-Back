pipeline {
    agent any

    environment {
        DOCKER_IMAGE = 'juanjothin/vitalapp'
        DOCKER_TAG = 'latest'
        REGISTRY_CREDENTIALS = 'Token-docker'
        // Opcionales para Sonar/Prometheus
        SONAR_PROJECT_KEY = '${env.SONAR_PROJECT_KEY ?: "vitalcareback"}'
        PUSHGATEWAY_URL = '${env.PUSHGATEWAY_URL ?: ""}'
    }

    parameters {
        // Por defecto usar la rama 'Tests' (la rama donde tienes configurado el pipeline)
        string(name: 'GIT_BRANCH', defaultValue: 'Tests', description: 'Rama a compilar desde GitHub')
    }

    options {
        timestamps()
        // ansiColor requiere el plugin "AnsiColor" instalado/activo en Jenkins.
        // Si al ejecutar aparece "Invalid option type 'ansiColor'", es porque el plugin no está instalado
        // o está desactualizado. Puedes reinstalarlo/actualizarlo y volver a habilitar la línea siguiente.
        // ansiColor('xterm')
    }

    stages {
        stage('Checkout') {
            steps {
                deleteDir()
                checkout([$class: 'GitSCM',
                          branches: [[name: "*/${params.GIT_BRANCH}"]],
                          doGenerateSubmoduleConfigurations: false,
                          extensions: [],
                          userRemoteConfigs: [[url: 'https://github.com/londgav01S/VitalCare-Back.git']]])
            }
        }

        stage('Compilar (Gradle)') {
            steps {
                sh 'chmod +x ./gradlew'
                sh "rm -rf ${env.HOME}/.gradle"
                sh './gradlew clean'
                // Construye el artefacto sin ejecutar tests
                sh './gradlew bootJar -x test'
            }
        }

        stage('Análisis SonarQube') {
            steps {
                withSonarQubeEnv('sonarqube-local') {
                    script {
                        echo "=== DEBUG: Variables de entorno Sonar ==="
                        sh 'echo "SONAR_HOST_URL = $SONAR_HOST_URL"'
                        sh 'echo "SONAR_AUTH_TOKEN = ${SONAR_AUTH_TOKEN:+***}"'
                        sh 'echo "Ejecutando análisis con Gradle..."'
                        sh './gradlew sonarqube -Dsonar.host.url=$SONAR_HOST_URL -Dsonar.login=$SONAR_AUTH_TOKEN'
                    }
                }
            }
        }

        stage('Tests (JUnit + Postman)') {
            steps {
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                    // Generar properties de test en el agente (H2 in-memory) para CI
                    // Esto evita subir archivos con secretos al repositorio.
                    sh '''
                        mkdir -p src/test/resources || true
                        cat > src/test/resources/application.properties <<'EOF'
                        # Test properties - generated by CI
                        spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL
                        spring.datasource.driver-class-name=org.h2.Driver
                        spring.datasource.username=sa
                        spring.datasource.password=
                        spring.jpa.hibernate.ddl-auto=create-drop
                        spring.jpa.show-sql=false
                        spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
                        sendgrid.api.key=
                        sendgrid.from.email=test@example.com
                        jwt.secret=test_jwt_secret
                        jwt.expirationMs=3600000
                        jwt.refreshExpirationMs=604800000
                        logging.level.org.springframework=ERROR
                        EOF
                    '''
                    // Ejecuta los tests JUnit que ya existen en el proyecto
                    sh './gradlew test'
                    // Generar reporte JaCoCo (si está configurado en build.gradle)
                    sh './gradlew jacocoTestReport || true'
                    // Publica resultados JUnit
                    junit 'build/test-results/test/*.xml'

                    // Archive Jacoco XML if exists
                    archiveArtifacts artifacts: 'build/reports/jacoco/test/jacocoTestReport.xml', allowEmptyArchive: true
                    archiveArtifacts artifacts: 'build/reports/jacoco/test/html/**', allowEmptyArchive: true

                    script {
                        // Tests de API (Postman/Newman) opcionales si existe la colección
                        if (fileExists('tests/postman_collection.json')) {
                            sh '''
                                echo "Levantando servidor Spring Boot para tests de API..."
                                nohup java -jar build/libs/*.jar --spring.profiles.active=test > app.log 2>&1 &
                                SERVER_PID=$!
                                sleep 15 || true
                                echo "Ejecutando tests Newman..."
                                newman run tests/postman_collection.json --insecure || true
                                echo "Deteniendo servidor..."
                                kill $SERVER_PID || true
                            '''
                        } else {
                            echo 'No se encontró tests/postman_collection.json; se omiten tests de Postman.'
                        }
                    }
                }
            }
        }

        stage('Publish metrics (Sonar -> Prometheus)') {
            steps {
                script {
                    // Only run if Sonar environment was available and project key set
                    if (!env.SONAR_PROJECT_KEY) {
                        echo "SONAR_PROJECT_KEY no está configurado; se omiten métricas Sonar."
                    } else if (!env.SONAR_HOST_URL) {
                        echo "SONAR_HOST_URL no disponible (comprueba configuración de withSonarQubeEnv); se omiten métricas Sonar."
                    } else {
                        echo "Consultando Sonar para proyecto ${env.SONAR_PROJECT_KEY}..."
                        // Try several times to let Sonar process the analysis
                        def attempts = 0
                        def maxAttempts = 12
                        def success = false
                        def apiUrl = "${env.SONAR_HOST_URL}/api/measures/component?component=${env.SONAR_PROJECT_KEY}&metricKeys=coverage,bugs,vulnerabilities,code_smells,duplicated_lines_density,ncloc"
                        while (attempts < maxAttempts) {
                            attempts++
                            echo "Intento ${attempts}/${maxAttempts} -> ${apiUrl}"
                            // write output to file
                            sh "curl -sS -u ${env.SONAR_AUTH_TOKEN}:' ' \"${apiUrl}\" -o sonar_metrics.json || true"
                            def content = readFile('sonar_metrics.json').trim()
                            if (content.contains('"measures"')) { success = true; break }
                            echo "Métricas aún no listas en Sonar; esperando 10s..."
                            sleep 10
                        }
                        if (!success) {
                            echo "No se obtuvieron métricas de Sonar después de ${maxAttempts} intentos. Revisa Sonar o el token."
                        } else {
                            // small python helper to parse Sonar JSON and push to Pushgateway
                            writeFile file: 'parse_and_push.py', text: '''#!/usr/bin/env python3
import sys, json, os, subprocess
try:
    data = json.load(sys.stdin)
except Exception as e:
    print('Error leyendo JSON de Sonar:', e)
    sys.exit(0)
measures = {m['metric']: m.get('value') for m in data.get('component', {}).get('measures', [])}
lines = []
prefix = 'vitalcare_sonar_'
for k, v in measures.items():
    try:
        val = float(v)
    except:
        continue
    name = prefix + k.replace('.', '_')
    lines.append(f"{name} {val}")
metrics_text = '\n'.join(lines) + '\n'
pgw = os.environ.get('PUSHGATEWAY_URL')
job = os.environ.get('SONAR_PROJECT_KEY', 'job')
if pgw:
    url = pgw.rstrip('/')
    target = f"{url}/metrics/job/{job}"
    p = subprocess.Popen(['curl','--silent','--show-error','--data-binary','@-', target], stdin=subprocess.PIPE)
    p.communicate(input=metrics_text.encode('utf-8'))
    print('Metrics pushed to', target)
else:
    print(metrics_text)
'''
                            sh 'cat sonar_metrics.json | python3 parse_and_push.py || true'
                        }
                    }
                }
            }
        }
    }
}
