pipeline {
    agent any

    environment {
        DOCKER_IMAGE = 'juanjothin/vitalapp'
        DOCKER_TAG = 'latest'
        REGISTRY_CREDENTIALS = 'Token-docker'
        // Opcionales para Sonar/Prometheus
        // Usa un valor por defecto simple; puedes sobrescribirlo con un parámetro de job o variable de entorno
        SONAR_PROJECT_KEY = 'vitalcareback'
        // Deja vacío por defecto; si defines PUSHGATEWAY_URL en el job, se usará ese
        PUSHGATEWAY_URL = ''
    }

    parameters {
        // Por defecto usar la rama 'Tests' (la rama donde tienes configurado el pipeline)
        string(name: 'GIT_BRANCH', defaultValue: 'Tests', description: 'Rama a compilar desde GitHub')
    }

    options {
        timestamps()
        // ansiColor requiere el plugin "AnsiColor" instalado/activo en Jenkins.
        // Si al ejecutar aparece "Invalid option type 'ansiColor'", es porque el plugin no está instalado
        // o está desactualizado. Puedes reinstalarlo/actualizarlo y volver a habilitar la línea siguiente.
        // ansiColor('xterm')
    }

    stages {
        stage('Checkout') {
            steps {
                deleteDir()
                checkout([$class: 'GitSCM',
                          branches: [[name: "*/${params.GIT_BRANCH}"]],
                          doGenerateSubmoduleConfigurations: false,
                          extensions: [],
                          userRemoteConfigs: [[url: 'https://github.com/londgav01S/VitalCare-Back.git']]])
            }
        }

        stage('Compilar (Gradle)') {
            steps {
                sh 'chmod +x ./gradlew'
                sh "rm -rf ${env.HOME}/.gradle"
                sh './gradlew clean'
                // Construye el artefacto sin ejecutar tests
                sh './gradlew bootJar -x test'
            }
        }

        stage('Análisis SonarQube') {
            steps {
                withSonarQubeEnv('sonarqube-local') {
                    script {
                        echo "=== DEBUG: Variables de entorno Sonar ==="
                        sh 'echo "SONAR_HOST_URL = $SONAR_HOST_URL"'
                        sh 'if [ -n "$SONAR_AUTH_TOKEN" ]; then echo "SONAR_AUTH_TOKEN = ***"; else echo "SONAR_AUTH_TOKEN = (empty)"; fi'
                        sh 'echo "Ejecutando análisis con Gradle..."'
                        sh './gradlew sonarqube -Dsonar.host.url=$SONAR_HOST_URL -Dsonar.login=$SONAR_AUTH_TOKEN'
                    }
                }
            }
        }

        stage('Tests (JUnit + Postman)') {
            steps {
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                    // Generar properties de test en el agente (H2 in-memory) para CI
                    // Esto evita subir archivos con secretos al repositorio.
                    sh '''
                        mkdir -p src/test/resources || true
                        cat > src/test/resources/application.properties <<'EOF'
                        # Test properties - generated by CI
                        spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL
                        spring.datasource.driver-class-name=org.h2.Driver
                        spring.datasource.username=sa
                        spring.datasource.password=
                        spring.jpa.hibernate.ddl-auto=create-drop
                        spring.jpa.show-sql=false
                        spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
                        sendgrid.api.key=
                        sendgrid.from.email=test@example.com
                        jwt.secret=test_jwt_secret
                        jwt.expirationMs=3600000
                        jwt.refreshExpirationMs=604800000
                        logging.level.org.springframework=ERROR
                        EOF
                    '''
                    // Ejecuta los tests JUnit que ya existen en el proyecto
                    sh './gradlew test'
                    // Generar reporte JaCoCo (si está configurado en build.gradle)
                    sh './gradlew jacocoTestReport || true'
                    // Publica resultados JUnit
                    junit 'build/test-results/test/*.xml'

                    // Archive Jacoco XML if exists
                    archiveArtifacts artifacts: 'build/reports/jacoco/test/jacocoTestReport.xml', allowEmptyArchive: true
                    archiveArtifacts artifacts: 'build/reports/jacoco/test/html/**', allowEmptyArchive: true

                    script {
                        // Tests de API (Postman/Newman) opcionales si existe la colección
                        if (fileExists('tests/postman_collection.json')) {
                            sh '''
                                echo "Levantando servidor Spring Boot para tests de API..."
                                nohup java -jar build/libs/*.jar --spring.profiles.active=test > app.log 2>&1 &
                                SERVER_PID=$!
                                sleep 15 || true
                                echo "Ejecutando tests Newman..."
                                newman run tests/postman_collection.json --insecure || true
                                echo "Deteniendo servidor..."
                                kill $SERVER_PID || true
                            '''
                        } else {
                            echo 'No se encontró tests/postman_collection.json; se omiten tests de Postman.'
                        }
                    }
                }
            }
        }

        stage('Doc Check (Javadoc)') {
            steps {
                script {
                    echo 'Generando Javadoc con doclint y Werror (fallará si falta documentación pública)...'
                }
                sh './gradlew javadoc'
                archiveArtifacts artifacts: 'build/docs/javadoc/**', allowEmptyArchive: true
            }
        }

        stage('Checkstyle') {
            steps {
                script { echo 'Ejecutando Checkstyle (missing Javadoc como error)...' }
                sh './gradlew checkstyleAll'
            }
            post {
                always {
                    recordIssues(tools: [checkStyle(pattern: 'build/reports/checkstyle/*.xml')])
                    archiveArtifacts artifacts: 'build/reports/checkstyle/**', allowEmptyArchive: true
                }
            }
        }

        // Esperar el Quality Gate (opcional, asegura que Sonar procesó antes de pedir métricas)
        stage('Quality Gate') {
            steps {
                withSonarQubeEnv('sonarqube-local') {
                    // Espera hasta que la tarea de análisis termine (sonar scanner ya corrió antes)
                    timeout(time: 5, unit: 'MINUTES') {
                        script {
                            def qg = waitForQualityGate()
                            echo "Quality Gate status: ${qg.status}"
                        }
                    }
                }
            }
        }

        stage('Publish metrics (Sonar -> Prometheus)') {
            steps {
                withSonarQubeEnv('sonarqube-local') {
                    script {
                        // Obtén el projectKey con fallback seguro sin inyectar expresiones al shell
                        def projectKey = env.SONAR_PROJECT_KEY ?: 'vitalcareback'
                        if (!projectKey?.trim()) {
                            echo "SONAR_PROJECT_KEY no está configurado; se omiten métricas Sonar."
                            return
                        }
                        echo "Consultando Sonar para proyecto ${projectKey}..."
                        def attempts = 0
                        def maxAttempts = 10
                        def success = false
                        def apiUrl = "${SONAR_HOST_URL}/api/measures/component?component=${projectKey}&metricKeys=coverage,bugs,vulnerabilities,code_smells,duplicated_lines_density,ncloc"
                        while (attempts < maxAttempts) {
                            attempts++
                            echo "Intento ${attempts}/${maxAttempts} -> ${apiUrl}"
                            // Nota: usamos Groovy para construir la URL, así el shell no ve expresiones ${...}
                            sh "curl -sS -u ${SONAR_AUTH_TOKEN}: '${apiUrl}' -o sonar_metrics.json || true"
                            def content = readFile('sonar_metrics.json').trim()
                            if (content.contains('"measures"')) { success = true; break }
                            echo "Métricas aún no listas; esperando 8s..."
                            sleep 8
                        }
                        if (!success) {
                            echo "No se obtuvieron métricas de Sonar tras ${maxAttempts} intentos."
                            return
                        }
                        writeFile file: 'parse_and_push.py', text: '''#!/usr/bin/env python3
import sys, json, os, subprocess
try:
    data = json.load(open('sonar_metrics.json'))
except Exception as e:
    print('Error leyendo JSON:', e)
    sys.exit(0)
measures = {m['metric']: m.get('value') for m in data.get('component', {}).get('measures', [])}
lines = []
prefix = 'vitalcare_sonar_'
for k, v in measures.items():
    try:
        val = float(v)
    except:
        continue
    name = prefix + k.replace('.', '_')
    lines.append(f"{name} {val}")
metrics_text = '\n'.join(lines) + '\n'
pgw = os.environ.get('PUSHGATEWAY_URL')
job = os.environ.get('SONAR_PROJECT_KEY', 'job')
if pgw:
    url = pgw.rstrip('/')
    target = f"{url}/metrics/job/{job}"
    p = subprocess.Popen(['curl','--silent','--show-error','--data-binary','@-', target], stdin=subprocess.PIPE)
    p.communicate(input=metrics_text.encode('utf-8'))
    print('Metrics pushed to', target)
else:
    print(metrics_text)
'''
                        sh 'python3 parse_and_push.py || true'
                    }
                }
            }
        }
    }
}
